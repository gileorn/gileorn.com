---
title: Create your own developer blog from scratch with React and Next.js
description: Step-by-step walkthrough of how I created a smiple static blog with React, Next.js, Tailwind.css and Contentlayer
date: 2023-10-05
tags: ['React', 'Next.js', 'Tailwind', 'AWS', 'Vercel']
---

## Motivation

With the fifth year of my career as a frontend developer coming to an end, I felt like I finally had enough confidence and motivation to start sharing my knowledge and opinions. The last two years were so eventful that I have a dozen of ideas and drafts of live talks, presentations and articles. I've significantly improved my English skills and found out that writing technical stuff comes natural to me and I only needed to decide where and how do I want to publish my content.

With Twitter becoming an impression-farming click-baiting shitshow and Medium filling half of my screen with paid subscription promotion, there wasn't any other option for me but to build my own blog the way I want it to be. I want to own my content, distribute it for free and not be too dependant on any platform or tool.

![Medium subscription promotion](/img/posts/hello-world-devblog/medium.png)
Not going to invest my time for content that will end up looking like this.

## MVP functionality

I started writing the code and exploring available tools for my goal right away, with a simple goal in mind "fully self-hosted blog with short info about myself and rich article contents such as images, videos, code examples and more". This definition of what I want to get in the end was constantly changing with me acquiring more context and with every minor success. I didn't want to settle for some mediocre thing that doesn't look or feel good enough so that I'd personally read a long article there.

This is the final set of things that I considered as required to be done before I announce and get my blog out to the world:

- Visually attractive, minimalistic UI with responsivness, adapted for mobile phones
- Small about section with social links
- Posts that are statically generated from MDX files with a result of Notion-like layout
- Dynamic table of contents for each post with active section higlighting
- Fully functional comment section with social login through 3rd party provider
- Code snipets with syntax highlighting
- Dark mode
- Likes and views counters
- Easy deploy, minimal maintenance
- Analytics with SaaS intergration
- Error tracking with SaaS intrgration
- Basic monitoring of the instance running in the cloud

Things I left for later:

- Appearances page
- Bookmars page with books, articles and talks recommendations
- Posts page with tags, filtering and pagination
- Career section: CV, job history, projects and other stuff
- Native comments section
- Fullscreen image view
- Collapsable code blocks with previews

## How this blog is built

### Visual design

Before all the technical stuff, I want first to highlight how unexpectedly difficult was creating the visual side of this blog. I've always known that UI designers' work is pretty hard and challenging, but the situation when you have a blank sheet and you need to start building something that looks attractive was something special to me.

I had no idea of how I want my blog to look like so I looked for some references. [Glenn Reyes's blog](https://glennreyes.com/) inspired by [Tailwind's Spotlight template](https://tailwindui.com/templates/spotlight) was one of the first ones I found. [Ekom Enyong's blog](https://ekomenyongcom-8288jhp5g-ekomenyong.vercel.app/) helped me finalize some details of the post page including table of contents and post header.

I personally was gravitating towards simple yet plesant and contrast look. After experimenting with some colorschemes and even trying to fit my favourite [Catpuccin theme](https://github.com/catppuccin/catppuccin), I ended up defining custom colorscheme with one contrast color similar to [Dan Abramov's personal blog](https://overreacted.io/).

### React and Next.js as a foundation

React was a natural choice for me. Even though I briefly tried some other UI libraries, it never clicked for me as much as React did. Bit I already felt that somehow I'd been missing a very important thing in the React ecosystem and frontend industry in general - Next.js framework. At the start of this project, I didn't know a thing about it and decided to give it a try no matter if I like it or not, at least to form a solid opinion about it and stop feeling like I'm missing something big in the industry.

I want to briefly highligh some of the impressions I formed about Next.js after launching this blog. What I liked from the start is that Next.js allows you to easily customize the way you want to build and deploy your app, that includes server-side rendering and static site generation. Routing based on the file system is a thing that I've always wanted to have as a frontend developer. The architecture with separate layouts and pages that can be wrapped in each other is very pleasant to use.

And on the negative side I can say that although the docs seem pretty detailed, I found most of the pages being not too helpful. Also, the fact that there are basically two major branches of versions of Next.js (app router and pages router) was confusing from the start. I found myself consulting the docs of pages router and not noticing it until there clearly were some contradictory instructions and I brought my eyes over the router selector and taking a deep breath.

### AWS Amplify for deployment

Vercel seemed to me as an important piece of the frontend industry puzzle that I had been missing, similar to Next.js. First versions of my blog were deployed with ease with Vercel, but later I decided to move to AWS. I had two reasons for that. The first one is that I've already had the base level certification for AWS ([Cloud Practitioner](https://aws.amazon.com/certification/certified-cloud-practitioner/)) and I wanted to continue my path towards more complex certifications. I didn't have any chance to do that aside from the regular work, and blog seemed like a great fit. Up until the end of the development process I had set up both AWS and Vercel deployment and that allowed me to explore their differences. The second reason of why I chose AWS over Vercel was that I imagined this blog serving as a playground for me exploring different subjects of software engineering, leaning towards full-stack development. All these ideas require fully capable cloud infrastructure so I decided to not waste my time on half-measures or having troubles integration my frontend app hosted on Vercel with other parts of the system hosted on AWS.

Being familiar with AWS platform, I was pleasanlty surprised with their answer to Vercel - [AWS Amplify](https://aws.amazon.com/amplify/). It was very easy to set up deployment just like with Vercel. All the details related to Next.js were automatically detected and the deployment simply worked. I bought domain gileorn.com with AWS Route 53 and the integration with Amplify was as easy as you might expect.

![AWS Amplify Console](/img/posts/hello-world-devblog/amplify.png)

The next discovery happened when I wanted to set up basic monitoring of the running application: number of requests and response codes. With AWS Amplify everything started working out of the box with the dedicated monitoring tab in Amplify console that included a simple AWS CloudWatch dashboard with 5 graphs. It was all I needed at this point. And with Vercel... well, I needed to 1) switch to PRO plan (20$ per month) 2) buy "monitoring" add-on (10$ per month per one user). And they don't even have some preview, trial or limited data access so I could understand what's under the paywall and if I want it or not. As you can probably guess, at this moment I was thinking that moving from Vercel was the right decision.

![AWS Amplify Monitoring Tab](/img/posts/hello-world-devblog/amplify-monitoring.png)
AWS Amplify Monitoring tab powered by AWS CloudWatch

### Tailwind for styling

Tailwind was yet another thing that I never tried but always wanted to go beyond reading the docs. Utility classes concept was not a new thing for me, but I've only encountered some custom implementations of it haven't seen any project taking full advantage of Tailwind.

As a new Tailwind user, I spent a lot of time consulting the docs to understand not only what class am I searching for, but more basic principles behind it and different ways of how I can customize my setup. One of the first thing I tried to solve was the following use case:

I wanted my colorscheme to be in one place and easily customizable without doing any mass-replaces across the whole codebase and (of course) accidentally affect some wrong things. I also wanted to avoid bloated classname strings that I sometimes see in the source code of some projects and that make me question the whole atomic css movement. 7 classes seems like the treshold at which it becomes hard to read and maintain.

```html
<!-- Hardcoded color values, easy to forget about dark theme support -->
<div class="text-zinc-50 dark:text-zinc-800"></div>
<!-- Custom color values that are easy to change in one place -->
<!-- But it is still easy to forget about dark theme support -->
<div class="text-m-main dark:text-m-dark-main"></div>
<!-- This is what I want to be equivalent to what's above -->
<div class="text-main"></div>
```

To achieve that I declared a set of custom colors with a prefix 'm-' to avoid any naming conflicts.

```ts showLineNumbers
// tailwind.config.ts

import type { Config } from 'tailwindcss'
import colors from 'tailwindcss/colors'

const config: Config = {
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        // text and base colors
        'm-main': colors.zinc[800],
        'm-dark-main': colors.zinc[50],
        'm-accent': colors.indigo[400],
        'm-dark-accent': colors.indigo[300],
        'm-secondary': colors.zinc[500],
        'm-dark-secondary': colors.stone[300],
        // background colors
        'm-background': colors.zinc[100],
        'm-dark-background': colors.zinc[700],
        'm-foreground': colors.white,
        // ... and so on
      },
    },
  },
}
```

```css showLineNumbers
/* globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer utilities {
  /* --- text --- */
  .text-main {
    @apply text-m-main dark:text-m-dark-main;
  }
  .text-accent {
    @apply text-m-accent dark:text-m-dark-accent;
  }
  .text-hover {
    @apply hover:text-m-hover dark:hover:text-m-dark-hover;
  }
  .text-secondary {
    @apply text-m-secondary dark:text-m-dark-secondary;
  }

  /* ...the same approach for background, hover effects, etc... */
}
```

An

### Contentlayer for posts management

Simplifies the usage of mdx files as posts

```tsx showLineNumbers
import { defineDocumentType, makeSource } from 'contentlayer/source-files'

export const Post = defineDocumentType(() => ({
  name: 'Post',
  contentType: 'mdx',
  filePathPattern: `**/*.mdx`,
  fields: {
    title: { type: 'string', required: true },
    date: { type: 'date', required: true },
    description: { type: 'string', required: false },
    tags: { type: 'list', of: { type: 'string' }, required: false },
    teaser: { type: 'boolean', required: false },
  },
  computedFields: {
    url: {
      type: 'string',
      resolve: (post) => `/posts/${post._raw.flattenedPath}`,
    },
  },
}))

export default makeSource({
  contentDirPath: 'data/posts',
  documentTypes: [Post],
})
```

And here's how I initialize these fields with values in this exact post which is an .mdx file.

```md showLineNumbers
---
title: Create your own developer blog from scratch with React and Next.js
description: Step-by-step walkthrough of how I created a smiple static blog with React, Next.js, Tailwind.css and Contentlayer
date: 2023-10-05
tags: ['React', 'Next.js', 'Tailwind', 'AWS', 'Vercel']
---

...all the other content
```

### Supabase and PostgreSQL for storing likes and views

A blog without like button? Without a proper views counter? Not for me.

```sql showLineNumbers
declare new_likes int4;

begin
  select likes
  into new_likes
  from public.posts
  where post_id = postid;
  new_likes = new_likes + 1;
  update public.posts
  set likes = new_likes
  where post_id = postid;
  return new_likes;
end;
```

### Giscus for comments

This app was a such a relief for me when I first found it. Comments seemed like one of the most complex and resource-consuming thing to build if we're talking about some MVP and limited use of database. Giscus is a very simple to use integration with GutHub Discussions ap. Giscus wraps the GitHub Discussions API to provide a very convenient way to integrate comments and reactions for your blog with GitHub authentication. And there's a dedicated npm package for React that made the integration even easier. Great app, huge props to creators, nothing much to say here.

To illustrate it's work, here's the UI that lazily initiates on the page once the page is scrolled to the bottom.
And here's what's happening under the hood in the GitHub Discussions section in my repository.

![UI of the comments section](/img/posts/hello-world-devblog/giscus.jpg)

### Plausible for analytics

![Plausible SaaS for analytics](/img/posts/hello-world-devblog/plausible.png)

### Highlight.io for error tracking

![UI of the comments section](/img/posts/hello-world-devblog/highlight.png)

### Prism.js and Rehype for code syntax highlighting

## Next steps

## Drafts

I started off with many ideas of what I'd like to see in my blog. As in any real life project, eventually I decided to not overcomplicate things and start with the minimum functionality:

- Home page with some basic info about me, including a small widget about my career and social link
- Post page with markdown content and comments based on GitHub profile

Most of these are >80% finished, but still not quite ready to be published, because this final push, polishing and searching for rough edges is one thing that is hard for me as a perfectionist.

- React and Next.js as a foundation
- Contentlayer for using mdx files as posts
- Tailwind.css for styling
- Next.UI as a UI library
- Giscuss for comment section with Github discussions under the hood
- AWS Route 53 and Amplify for domain registration and deploy
- Supabase and PostgreSQL as a database of choice for likes and views counters
- Prism.js for code syntax highlighting
- Plausible as a SaaS of choice for analytics
- Hihlight.io as a SaaS of choice for error tracking
